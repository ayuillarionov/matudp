function [bus, valid, offset] = deserializeBus_CerebusStatisticsBus(input, offset, valid)
%#codegen
% DO NOT EDIT: Auto-generated by 
%   writeDeserializeBusCode('CerebusStatisticsBus')

    in = typecast(input, 'uint8');
    if nargin < 2
         offset = uint32(1);
    end
    if nargin < 3
         valid = uint8(1);
    end
    offset = uint32(offset);

    bus = initializeBus_CerebusStatisticsBus();
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field numDroppedPackets
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(32 - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_numDroppedPackets = uint8([2, 4, typecast(uint16(17), 'uint8'), 'numDroppedPackets', typecast(uint16(7), 'uint8'), 'packets', 7, 1])';
    for headerOffset = 1:uint32(32-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_numDroppedPackets(headerOffset));
    end
    offset = offset + uint32(32);

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.numDroppedPackets = zeros([1 1], 'uint32');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*4 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.numDroppedPackets = zeros([1 1], 'uint32');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.numDroppedPackets = zeros([1 1], 'uint32');
            if elements > uint32(0)
                bus.numDroppedPackets(1:elements) = typecast(in(offset:offset+uint32(elements*4 - 1))', 'uint32')';
                offset = offset + uint32(elements*4);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field lastPacketNumber
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(24 - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_lastPacketNumber = uint8([2, 4, typecast(uint16(16), 'uint8'), 'lastPacketNumber', typecast(uint16(0), 'uint8'), '', 6, 1])';
    for headerOffset = 1:uint32(24-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_lastPacketNumber(headerOffset));
    end
    offset = offset + uint32(24);

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.lastPacketNumber = zeros([1 1], 'int32');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*4 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.lastPacketNumber = zeros([1 1], 'int32');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.lastPacketNumber = zeros([1 1], 'int32');
            if elements > uint32(0)
                bus.lastPacketNumber(1:elements) = typecast(in(offset:offset+uint32(elements*4 - 1))', 'int32')';
                offset = offset + uint32(elements*4);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field lastClock
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(22 - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_lastClock = uint8([2, 4, typecast(uint16(9), 'uint8'), 'lastClock', typecast(uint16(5), 'uint8'), 'ms/30', 7, 1])';
    for headerOffset = 1:uint32(22-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_lastClock(headerOffset));
    end
    offset = offset + uint32(22);

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.lastClock = zeros([1 1], 'uint32');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*4 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.lastClock = zeros([1 1], 'uint32');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.lastClock = zeros([1 1], 'uint32');
            if elements > uint32(0)
                bus.lastClock(1:elements) = typecast(in(offset:offset+uint32(elements*4 - 1))', 'uint32')';
                offset = offset + uint32(elements*4);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field clockOffset
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(21 - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_clockOffset = uint8([2, 2, typecast(uint16(11), 'uint8'), 'clockOffset', typecast(uint16(2), 'uint8'), 'ms', 1, 1])';
    for headerOffset = 1:uint32(21-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_clockOffset(headerOffset));
    end
    offset = offset + uint32(21);

    % Establishing size
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.clockOffset = zeros([1 1], 'single');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*4 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.clockOffset = zeros([1 1], 'single');
        else
            % read and typecast data
            assert(elements <= uint32(1));
            bus.clockOffset = zeros([1 1], 'single');
            if elements > uint32(0)
                bus.clockOffset(1:elements) = typecast(in(offset:offset+uint32(elements*4 - 1))', 'single')';
                offset = offset + uint32(elements*4);
            end
        end
    end


end