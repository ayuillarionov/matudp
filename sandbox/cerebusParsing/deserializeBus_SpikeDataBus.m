function [bus, valid, offset] = deserializeBus_SpikeDataBus(input, offset, valid)
%#codegen
% DO NOT EDIT: Auto-generated by 
%   writeDeserializeBusCode('SpikeDataBus')

    in = typecast(input, 'uint8');
    if nargin < 2
         offset = uint32(1);
    end
    if nargin < 3
         valid = uint8(1);
    end
    offset = uint32(offset);

    bus = initializeBus_SpikeDataBus();
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing variable-sized field spikeTimeOffsets
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(26 - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_spikeTimeOffsets = uint8([3, 2, typecast(uint16(16), 'uint8'), 'spikeTimeOffsets', typecast(uint16(2), 'uint8'), 'ms', 1, 1])';
    for headerOffset = 1:uint32(26-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_spikeTimeOffsets(headerOffset));
    end
    offset = offset + uint32(26);

    % Establishing size
    coder.varsize('bus.spikeTimeOffsets', 128);
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.spikeTimeOffsets = zeros([128 1], 'single');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) > uint16(128), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*4 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.spikeTimeOffsets = zeros([0 1], 'single');
        else
            % mollify codegen
            assert(sz(1) <= uint16(128));
            % read and typecast data
            assert(elements <= uint32(128));
            bus.spikeTimeOffsets = zeros([sz uint16(1)], 'single');
            if elements > uint32(0)
                bus.spikeTimeOffsets(1:elements) = typecast(in(offset:offset+uint32(elements*4 - 1))', 'single')';
                offset = offset + uint32(elements*4);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing variable-sized field spikeChannels
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(21 - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_spikeChannels = uint8([3, 5, typecast(uint16(13), 'uint8'), 'spikeChannels', typecast(uint16(0), 'uint8'), '', 3, 1])';
    for headerOffset = 1:uint32(21-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_spikeChannels(headerOffset));
    end
    offset = offset + uint32(21);

    % Establishing size
    coder.varsize('bus.spikeChannels', 128);
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.spikeChannels = zeros([128 1], 'uint8');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) > uint16(128), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*1 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.spikeChannels = zeros([0 1], 'uint8');
        else
            % mollify codegen
            assert(sz(1) <= uint16(128));
            % read and typecast data
            assert(elements <= uint32(128));
            bus.spikeChannels = zeros([sz uint16(1)], 'uint8');
            if elements > uint32(0)
                bus.spikeChannels(1:elements) = typecast(in(offset:offset+uint32(elements*1 - 1))', 'uint8')';
                offset = offset + uint32(elements*1);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing variable-sized field spikeUnits
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(18 - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_spikeUnits = uint8([3, 5, typecast(uint16(10), 'uint8'), 'spikeUnits', typecast(uint16(0), 'uint8'), '', 3, 1])';
    for headerOffset = 1:uint32(18-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_spikeUnits(headerOffset));
    end
    offset = offset + uint32(18);

    % Establishing size
    coder.varsize('bus.spikeUnits', 128);
    if valid == uint8(0) || offset + uint32(2 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.spikeUnits = zeros([128 1], 'uint8');
    else
        sz = typecast(in(offset:(offset+uint32(2-1))), 'uint16')';
        offset = offset + uint32(2);
        % check size
        if sz(1) > uint16(128), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:1
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*1 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.spikeUnits = zeros([0 1], 'uint8');
        else
            % mollify codegen
            assert(sz(1) <= uint16(128));
            % read and typecast data
            assert(elements <= uint32(128));
            bus.spikeUnits = zeros([sz uint16(1)], 'uint8');
            if elements > uint32(0)
                bus.spikeUnits(1:elements) = typecast(in(offset:offset+uint32(elements*1 - 1))', 'uint8')';
                offset = offset + uint32(elements*1);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing variable-sized field spikeWaveforms
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint32(24 - 1) > numel(in)
        valid = uint8(0);
    end
    expectedHeader_spikeWaveforms = uint8([3, 5, typecast(uint16(14), 'uint8'), 'spikeWaveforms', typecast(uint16(2), 'uint8'), 'mV', 4, 2])';
    for headerOffset = 1:uint32(24-1)
        valid = uint8(valid && in(offset+headerOffset-1) == expectedHeader_spikeWaveforms(headerOffset));
    end
    offset = offset + uint32(24);

    % Establishing size
    coder.varsize('bus.spikeWaveforms', [48 128]);
    if valid == uint8(0) || offset + uint32(4 - 1) > numel(in)
        % buffer not large enough for header
        valid = uint8(0);
        bus.spikeWaveforms = zeros([48 128], 'int16');
    else
        sz = typecast(in(offset:(offset+uint32(4-1))), 'uint16')';
        offset = offset + uint32(4);
        % check size
        if sz(1) > uint16(48), valid = uint8(0); end
        if sz(2) > uint16(128), valid = uint8(0); end
        elements = uint32(1);
        for i = 1:2
             elements = elements * uint32(sz(i));
        end
        if elements > uint32(0) && offset + uint32(elements*2 - 1) > numel(in)
            % buffer not large enough for data
            valid = uint8(0);
        end
        if valid && elements == uint32(0)
            % assigning empty value
            bus.spikeWaveforms = zeros([48 0], 'int16');
        else
            % mollify codegen
            assert(sz(1) <= uint16(48));
            assert(sz(2) <= uint16(128));
            % read and typecast data
            assert(elements <= uint32(6144));
            bus.spikeWaveforms = zeros(sz, 'int16');
            if elements > uint32(0)
                bus.spikeWaveforms(1:elements) = typecast(in(offset:offset+uint32(elements*2 - 1))', 'int16')';
                offset = offset + uint32(elements*2);
            end
        end
    end


end