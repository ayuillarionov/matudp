function [out, valid] = serializeBusWithDataLoggerHeader_SpikeDataBus(bus, groupType, groupName, timestamp, namePrefix)
%#codegen
% DO NOT EDIT: Auto-generated by 
%   BusSerialize.writeSerializeBusCode('SpikeDataBus')

    if nargin < 5, namePrefix = uint8(''); end
    namePrefixBytes = uint8(namePrefix(:))';
    valid = uint8(0);
    headerLength = uint32(BusSerialize.computeDataLoggerHeaderLength(uint8([namePrefixBytes, groupName])));
    coder.varsize('out', 13155 + headerLength);
    outSize = headerLength + getSerializedBusLength_SpikeDataBus(bus, namePrefix);
    out = zeros(outSize, 1, 'uint8');
    offset = uint32(1);

    % Serialize data logger header
    header = BusSerialize.serializeDataLoggerHeader(groupType, uint8([namePrefixBytes, groupName]), uint32(1815354714), uint16(4), timestamp);
    out(1:headerLength) = uint8(header);
    offset = offset + headerLength;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize variable-sized spikeTimeOffsets
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.spikeTimeOffsets) <= 128, 'numel(bus.spikeTimeOffsets) exceeds max size of 128');    % spikeTimeOffsets bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(3);
    offset = offset + uint32(1);

    % spikeTimeOffsets signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);

    % spikeTimeOffsets name with prefix 
    if(offset+uint32(2+16 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 16), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 16-1))) = [namePrefixBytes, uint8('spikeTimeOffsets')];
    offset = offset + uint32(numel(namePrefixBytes) + 16);

    % spikeTimeOffsets units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('ms');
    offset = offset + uint32(2);

    % spikeTimeOffsets data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(1); % data type is single
    offset = offset + uint32(1);

    % spikeTimeOffsets dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.spikeTimeOffsets)), 'uint8');
    offset = offset + uint32(2*1);

    % spikeTimeOffsets data
    nBytes = uint32(4 * numel(bus.spikeTimeOffsets));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(single(bus.spikeTimeOffsets(:))', 'uint8')';
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize variable-sized spikeChannels
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.spikeChannels) <= 128, 'numel(bus.spikeChannels) exceeds max size of 128');    % spikeChannels bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(3);
    offset = offset + uint32(1);

    % spikeChannels signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(5);
    offset = offset + uint32(1);

    % spikeChannels name with prefix 
    if(offset+uint32(2+13 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 13), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 13-1))) = [namePrefixBytes, uint8('spikeChannels')];
    offset = offset + uint32(numel(namePrefixBytes) + 13);

    % spikeChannels units
    if(offset+uint32(2+0 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(0), 'uint8');
    offset = offset + uint32(2);

    % spikeChannels data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(3); % data type is uint8
    offset = offset + uint32(1);

    % spikeChannels dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.spikeChannels)), 'uint8');
    offset = offset + uint32(2*1);

    % spikeChannels data
    nBytes = uint32(1 * numel(bus.spikeChannels));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = uint8(bus.spikeChannels(:));
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize variable-sized spikeUnits
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(numel(bus.spikeUnits) <= 128, 'numel(bus.spikeUnits) exceeds max size of 128');    % spikeUnits bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(3);
    offset = offset + uint32(1);

    % spikeUnits signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(5);
    offset = offset + uint32(1);

    % spikeUnits name with prefix 
    if(offset+uint32(2+10 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 10), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 10-1))) = [namePrefixBytes, uint8('spikeUnits')];
    offset = offset + uint32(numel(namePrefixBytes) + 10);

    % spikeUnits units
    if(offset+uint32(2+0 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(0), 'uint8');
    offset = offset + uint32(2);

    % spikeUnits data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(3); % data type is uint8
    offset = offset + uint32(1);

    % spikeUnits dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*1-1) > numel(out)), return, end
    out(offset) = uint8(1);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*1-1))) = typecast(uint16(numel(bus.spikeUnits)), 'uint8');
    offset = offset + uint32(2*1);

    % spikeUnits data
    nBytes = uint32(1 * numel(bus.spikeUnits));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = uint8(bus.spikeUnits(:));
    end
    offset = offset + nBytes;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Serialize variable-sized spikeWaveforms
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Check input size is valid
    assert(ndims(bus.spikeWaveforms) == 2, 'ndims(bus.spikeWaveforms) must be 2');    assert(size(bus.spikeWaveforms, 1) == 48, 'size(bus.spikeWaveforms, 1) must be 48');    assert(size(bus.spikeWaveforms, 2) <= 128, 'size(bus.spikeWaveforms, 2) exceeds max size of 128');    % spikeWaveforms bitFlags
    if(offset > numel(out)), return, end
    out(offset) = uint8(3);
    offset = offset + uint32(1);

    % spikeWaveforms signal type
    if(offset > numel(out)), return, end
    out(offset) = uint8(5);
    offset = offset + uint32(1);

    % spikeWaveforms name with prefix 
    if(offset+uint32(2+14 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(numel(namePrefixBytes) + 14), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(numel(namePrefixBytes) + 14-1))) = [namePrefixBytes, uint8('spikeWaveforms')];
    offset = offset + uint32(numel(namePrefixBytes) + 14);

    % spikeWaveforms units
    if(offset+uint32(2+2 -1) > numel(out)), return, end
    out(offset:(offset+uint32(1))) = typecast(uint16(2), 'uint8');
    offset = offset + uint32(2);
    out(offset:(offset+uint32(2-1))) = uint8('mV');
    offset = offset + uint32(2);

    % spikeWaveforms data type id
    if(offset > numel(out)), return, end
    out(offset) = uint8(4); % data type is int16
    offset = offset + uint32(1);

    % spikeWaveforms dimensions
    if(offset > numel(out)), return, end
    if(offset+uint32(1+2*2-1) > numel(out)), return, end
    out(offset) = uint8(2);
    offset = offset + uint32(1);
    out(offset:(offset+uint32(2*2-1))) = typecast(uint16(size(bus.spikeWaveforms)), 'uint8');
    offset = offset + uint32(2*2);

    % spikeWaveforms data
    nBytes = uint32(2 * size(bus.spikeWaveforms, 1) * size(bus.spikeWaveforms, 2));
    if nBytes > uint32(0)
        if(offset+uint32(nBytes-1) > numel(out)), return, end
        out(offset:(offset+uint32(nBytes-1))) = typecast(int16(bus.spikeWaveforms(:))', 'uint8')';
    end
    offset = offset + nBytes; %#ok<NASGU>

    valid = uint8(1);
end