function [bus, valid, offset] = deserializeBus_TestBus(in, offset, valid)
%#codegen
% DO NOT EDIT: Auto-generated by 
%   writeDeserializeBusModelPackagedCode('testDataLogger', 'TestBus')

    if nargin < 2
         offset = uint16(1);
    end
    if nargin < 3
         valid = uint8(1);
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing variable-sized field centerSize
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint16(21 - 1) > numel(in)
        valid = uint8(0);
    end
    if valid == uint8(0) || ~isequal(in(offset:offset+uint16(21-1)), ...
        uint8([1, 4, 0, typecast(uint16(10), 'uint8'), 'centerSize', typecast(uint16(2), 'uint8'), 'mm', 3, 2]'))
        valid = uint8(0);
    end
    offset = offset + uint16(21);

    % Establishing size
    coder.varsize('bus.centerSize', [255 25]);
    if valid == uint8(0) || offset + uint16(4 - 1) > numel(in)
        % buffer not large enough
        valid = uint8(0);
        bus.centerSize = zeros([255 25], 'uint8');
    else
        sz = typecast(in(offset:(offset+uint16(4-1))), 'uint16')';
        offset = offset + uint16(4);
        % check size
        if sz(1) > uint16(255), valid = uint8(0); end
        if sz(2) > uint16(25), valid = uint8(0); end
        elements = uint16(1);
        for i = 1:2
             elements = elements * uint16(sz(i));
        end
        if valid == uint8(0) || offset + uint16(elements*1 - 1) > numel(in)
            % buffer not large enough
            valid = uint8(0);
            bus.centerSize = zeros([1 1], 'uint8');
        else
            % mollify codegen
            assert(sz(1) <= uint16(255));
            assert(sz(2) <= uint16(25));
            % read and typecast data
            assert(elements <= uint16(6375));
            bus.centerSize = zeros(sz, 'uint8');
            if elements > uint16(0)
                bus.centerSize(1:elements) = typecast(in(offset:offset+uint16(elements*1 - 1)), 'uint8');
                offset = offset + uint16(elements*1);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing fixed-sized field holdWindowCenter
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint16(27 - 1) > numel(in)
        valid = uint8(0);
    end
    if valid == uint8(0) || ~isequal(in(offset:offset+uint16(27-1)), ...
        uint8([0, 4, 0, typecast(uint16(16), 'uint8'), 'holdWindowCenter', typecast(uint16(2), 'uint8'), 'mm', 3, 1]'))
        valid = uint8(0);
    end
    offset = offset + uint16(27);

    % Establishing size
    if valid == uint8(0) || offset + uint16(2 - 1) > numel(in)
        % buffer not large enough
        valid = uint8(0);
        bus.holdWindowCenter = zeros([1 1], 'uint8');
    else
        sz = typecast(in(offset:(offset+uint16(2-1))), 'uint16')';
        offset = offset + uint16(2);
        % check size
        if sz(1) ~= uint16(1), valid = uint8(0); end
        elements = uint16(1);
        for i = 1:1
             elements = elements * uint16(sz(i));
        end
        if valid == uint8(0) || offset + uint16(elements*1 - 1) > numel(in)
            % buffer not large enough
            valid = uint8(0);
            bus.holdWindowCenter = zeros([1 1], 'uint8');
        else
            % read and typecast data
            assert(elements <= uint16(1));
            bus.holdWindowCenter = zeros([1 1], 'uint8');
            if elements > uint16(0)
                bus.holdWindowCenter(1:elements) = typecast(in(offset:offset+uint16(elements*1 - 1)), 'uint8');
                offset = offset + uint16(elements*1);
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Deserializing variable-sized field holdWindowTarget
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Checking header
    if valid == uint8(0) || offset + uint16(29 - 1) > numel(in)
        valid = uint8(0);
    end
    if valid == uint8(0) || ~isequal(in(offset:offset+uint16(29-1)), ...
        uint8([1, 4, 0, typecast(uint16(16), 'uint8'), 'holdWindowTarget', typecast(uint16(4), 'uint8'), 'char', 8, 1]'))
        valid = uint8(0);
    end
    offset = offset + uint16(29);

    % Establishing size
    coder.varsize('bus.holdWindowTarget', 30);
    if valid == uint8(0) || offset + uint16(2 - 1) > numel(in)
        % buffer not large enough
        valid = uint8(0);
        bus.holdWindowTarget = zeros([30 1], 'uint8');
    else
        sz = typecast(in(offset:(offset+uint16(2-1))), 'uint16')';
        offset = offset + uint16(2);
        % check size
        if sz(1) > uint16(30), valid = uint8(0); end
        elements = uint16(1);
        for i = 1:1
             elements = elements * uint16(sz(i));
        end
        if valid == uint8(0) || offset + uint16(elements*1 - 1) > numel(in)
            % buffer not large enough
            valid = uint8(0);
            bus.holdWindowTarget = zeros([1 1], 'uint8');
        else
            % mollify codegen
            assert(sz(1) <= uint16(30));
            % read and typecast data
            assert(elements <= uint16(30));
            bus.holdWindowTarget = zeros([sz uint16(1)], 'uint8');
            if elements > uint16(0)
                bus.holdWindowTarget(1:elements) = typecast(in(offset:offset+uint16(elements*1 - 1)), 'uint8');
                offset = offset + uint16(elements*1);
            end
        end
    end


end